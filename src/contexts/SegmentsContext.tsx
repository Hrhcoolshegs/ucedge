import { createContext, useContext, useState, ReactNode, useCallback, useEffect } from 'react';
import { Segment } from '@/types';
import { useData } from './DataContext';
import { SegmentEvaluator } from '@/services/segmentEvaluator';

interface SegmentsContextType {
  segments: Segment[];
  addSegment: (segment: Omit<Segment, 'id' | 'lastUpdated'>) => void;
  updateSegment: (id: string, updates: Partial<Segment>) => void;
  deleteSegment: (id: string) => void;
  getSegmentCustomers: (segmentId: string) => string[];
}

const SegmentsContext = createContext<SegmentsContextType | undefined>(undefined);

export const SegmentsProvider = ({ children }: { children: ReactNode }) => {
  const { customers } = useData();
  
  const [segments, setSegments] = useState<Segment[]>([
    {
      id: 'seg-1',
      name: 'High Value At-Risk',
      description: 'At-risk customers with LTV > ₦5M',
      type: 'auto',
      customerCount: 0,
      criteria: {
        lifecycleStages: ['at-risk'],
        customFilters: { minLTV: 5000000 }
      },
      metrics: {
        totalLTV: 0,
        avgLTV: 0,
        churnRate: 0,
        trend: 'stable'
      },
      lastUpdated: new Date().toISOString(),
      createdBy: 'System',
      isAutoGenerated: true
    },
    {
      id: 'seg-2',
      name: 'Churned Last 30 Days',
      description: 'Recently churned customers for winback',
      type: 'auto',
      customerCount: 0,
      criteria: {
        lifecycleStages: ['churned'],
        customFilters: { maxDaysSinceChurn: 30 }
      },
      metrics: {
        totalLTV: 0,
        avgLTV: 0,
        churnRate: 1,
        trend: 'up'
      },
      lastUpdated: new Date().toISOString(),
      createdBy: 'System',
      isAutoGenerated: true
    },
    {
      id: 'seg-3',
      name: 'Reactivation Candidates',
      description: 'Recently reactivated customers',
      type: 'lifecycle',
      customerCount: 0,
      criteria: {
        lifecycleStages: ['reactivated'],
      },
      metrics: {
        totalLTV: 0,
        avgLTV: 0,
        churnRate: 0.5,
        trend: 'down'
      },
      lastUpdated: new Date().toISOString(),
      createdBy: 'AI',
      isAutoGenerated: true
    },
    {
      id: 'seg-4',
      name: 'Loyal Customers',
      description: 'Long-term loyal customers with strong engagement',
      type: 'lifecycle',
      customerCount: 0,
      criteria: {
        lifecycleStages: ['loyal'],
      },
      metrics: {
        totalLTV: 0,
        avgLTV: 0,
        churnRate: 0.02,
        trend: 'stable'
      },
      lastUpdated: new Date().toISOString(),
      createdBy: 'System',
      isAutoGenerated: true
    },
    {
      id: 'seg-5',
      name: 'Active Customers',
      description: 'Currently active customer base',
      type: 'lifecycle',
      customerCount: 0,
      criteria: {
        lifecycleStages: ['active'],
      },
      metrics: {
        totalLTV: 0,
        avgLTV: 0,
        churnRate: 0.08,
        trend: 'up'
      },
      lastUpdated: new Date().toISOString(),
      createdBy: 'System',
      isAutoGenerated: true
    },
    {
      id: 'seg-6',
      name: 'New Customers',
      description: 'Recently onboarded customers',
      type: 'lifecycle',
      customerCount: 0,
      criteria: {
        lifecycleStages: ['new'],
      },
      metrics: {
        totalLTV: 0,
        avgLTV: 0,
        churnRate: 0.15,
        trend: 'up'
      },
      lastUpdated: new Date().toISOString(),
      createdBy: 'System',
      isAutoGenerated: true
    },
    {
      id: 'seg-7',
      name: 'High Engagement',
      description: 'Customers with high engagement levels',
      type: 'sentiment',
      customerCount: 0,
      criteria: {
        customFilters: { engagementLevels: ['high'] }
      },
      metrics: {
        totalLTV: 0,
        avgLTV: 0,
        churnRate: 0.05,
        trend: 'stable'
      },
      lastUpdated: new Date().toISOString(),
      createdBy: 'System',
      isAutoGenerated: true
    },
    {
      id: 'seg-8',
      name: 'High LTV Customers',
      description: 'Customers with lifetime value over ₦10M',
      type: 'custom',
      customerCount: 0,
      criteria: {
        customFilters: { minLTV: 10000000 }
      },
      metrics: {
        totalLTV: 0,
        avgLTV: 0,
        churnRate: 0.03,
        trend: 'stable'
      },
      lastUpdated: new Date().toISOString(),
      createdBy: 'System',
      isAutoGenerated: true
    },
  ]);

  const addSegment = useCallback((segment: Omit<Segment, 'id' | 'lastUpdated'>) => {
    const newSegment: Segment = {
      ...segment,
      id: `seg-${Date.now()}`,
      lastUpdated: new Date().toISOString()
    };
    setSegments(prev => [newSegment, ...prev]);
  }, []);

  const updateSegment = useCallback((id: string, updates: Partial<Segment>) => {
    setSegments(prev => prev.map(s => 
      s.id === id 
        ? { ...s, ...updates, lastUpdated: new Date().toISOString() }
        : s
    ));
  }, []);

  const deleteSegment = useCallback((id: string) => {
    setSegments(prev => prev.filter(s => s.id !== id));
  }, []);

  useEffect(() => {
    if (customers.length === 0) return;

    const reevaluateSegments = () => {
      setSegments(prevSegments =>
        prevSegments.map(segment => {
          const evaluation = SegmentEvaluator.evaluateSegment(segment, customers);
          return {
            ...segment,
            customerCount: evaluation.metrics.customerCount,
            metrics: {
              ...segment.metrics,
              ...evaluation.metrics,
            },
            lastUpdated: new Date().toISOString(),
          };
        })
      );
    };

    reevaluateSegments();

    const intervalId = setInterval(reevaluateSegments, 60000);

    return () => clearInterval(intervalId);
  }, [customers]);

  const getSegmentCustomers = useCallback((segmentId: string) => {
    const segment = segments.find(s => s.id === segmentId);
    if (!segment) return [];

    const evaluation = SegmentEvaluator.evaluateSegment(segment, customers);
    return evaluation.matchingCustomers.map(c => c.id);
  }, [segments, customers]);

  return (
    <SegmentsContext.Provider value={{ 
      segments, 
      addSegment, 
      updateSegment, 
      deleteSegment,
      getSegmentCustomers 
    }}>
      {children}
    </SegmentsContext.Provider>
  );
};

export const useSegments = () => {
  const context = useContext(SegmentsContext);
  if (!context) {
    throw new Error('useSegments must be used within SegmentsProvider');
  }
  return context;
};
