import { createContext, useContext, useState, ReactNode, useCallback } from 'react';
import { Segment } from '@/types';
import { useData } from './DataContext';

interface SegmentsContextType {
  segments: Segment[];
  addSegment: (segment: Omit<Segment, 'id' | 'lastUpdated'>) => void;
  updateSegment: (id: string, updates: Partial<Segment>) => void;
  deleteSegment: (id: string) => void;
  getSegmentCustomers: (segmentId: string) => string[];
}

const SegmentsContext = createContext<SegmentsContextType | undefined>(undefined);

export const SegmentsProvider = ({ children }: { children: ReactNode }) => {
  const { customers } = useData();
  
  const [segments, setSegments] = useState<Segment[]>([
    {
      id: 'seg-1',
      name: 'High Value At-Risk',
      description: 'At-risk customers with LTV > â‚¦5M',
      type: 'auto',
      customerCount: 0,
      criteria: {
        lifecycleStages: ['at-risk'],
        customFilters: { minLTV: 5000000 }
      },
      metrics: {
        totalLTV: 0,
        avgLTV: 0,
        churnRate: 0,
        trend: 'stable'
      },
      lastUpdated: new Date().toISOString(),
      createdBy: 'System',
      isAutoGenerated: true
    },
    {
      id: 'seg-2',
      name: 'Churned Last 30 Days',
      description: 'Recently churned customers for winback',
      type: 'auto',
      customerCount: 0,
      criteria: {
        lifecycleStages: ['churned'],
        customFilters: { maxDaysSinceChurn: 30 }
      },
      metrics: {
        totalLTV: 0,
        avgLTV: 0,
        churnRate: 1,
        trend: 'up'
      },
      lastUpdated: new Date().toISOString(),
      createdBy: 'System',
      isAutoGenerated: true
    },
    {
      id: 'seg-3',
      name: 'Reactivation Candidates',
      description: 'Churned customers with high reactivation probability',
      type: 'sentiment',
      customerCount: 0,
      criteria: {
        lifecycleStages: ['churned'],
        customFilters: { minReactivationProbability: 0.7 }
      },
      metrics: {
        totalLTV: 0,
        avgLTV: 0,
        churnRate: 0.5,
        trend: 'down'
      },
      lastUpdated: new Date().toISOString(),
      createdBy: 'AI',
      isAutoGenerated: true
    }
  ]);

  const addSegment = useCallback((segment: Omit<Segment, 'id' | 'lastUpdated'>) => {
    const newSegment: Segment = {
      ...segment,
      id: `seg-${Date.now()}`,
      lastUpdated: new Date().toISOString()
    };
    setSegments(prev => [newSegment, ...prev]);
  }, []);

  const updateSegment = useCallback((id: string, updates: Partial<Segment>) => {
    setSegments(prev => prev.map(s => 
      s.id === id 
        ? { ...s, ...updates, lastUpdated: new Date().toISOString() }
        : s
    ));
  }, []);

  const deleteSegment = useCallback((id: string) => {
    setSegments(prev => prev.filter(s => s.id !== id));
  }, []);

  const getSegmentCustomers = useCallback((segmentId: string) => {
    const segment = segments.find(s => s.id === segmentId);
    if (!segment) return [];

    return customers
      .filter(customer => {
        // Check lifecycle stages
        if (segment.criteria.lifecycleStages?.length) {
          if (!segment.criteria.lifecycleStages.includes(customer.lifecycleStage)) {
            return false;
          }
        }

        // Check custom filters
        if (segment.criteria.customFilters) {
          const filters = segment.criteria.customFilters;
          
          if (filters.minLTV && customer.lifetimeValue < filters.minLTV) return false;
          if (filters.maxLTV && customer.lifetimeValue > filters.maxLTV) return false;
          if (filters.maxDaysSinceChurn && customer.daysSinceChurn && customer.daysSinceChurn > filters.maxDaysSinceChurn) return false;
          if (filters.minReactivationProbability) return false; // Would need actual probability field
        }

        return true;
      })
      .map(c => c.id);
  }, [segments, customers]);

  return (
    <SegmentsContext.Provider value={{ 
      segments, 
      addSegment, 
      updateSegment, 
      deleteSegment,
      getSegmentCustomers 
    }}>
      {children}
    </SegmentsContext.Provider>
  );
};

export const useSegments = () => {
  const context = useContext(SegmentsContext);
  if (!context) {
    throw new Error('useSegments must be used within SegmentsProvider');
  }
  return context;
};
